---
description: "Enforce diverse, assertion-rich testing in Go using property-based, metamorphic, differential, mutation, and fuzz testing; treat coverage as a safety net, not a gate."
globs: **/*.go
alwaysApply: false
---

This rule instructs the assistant to prioritize test effectiveness over superficial metrics by 
generating numerous, diverse, and assertion-rich tests for all Go code matched by the globs. The 
goal is to increase true fault detection by combining property-based testing, metamorphic and 
differential oracles, mutation testing, and coverage-guided fuzzing. Code coverage is kept only as a 
safety net to reveal blind spots and is never used alone to prove correctness or to gate changes.

For each public function, the assistant first writes a short specification of properties and 
invariants in plain language and then implements property-based tests that exercise equivalence 
classes, boundary conditions, and randomized cases with shrinking to minimal counterexamples. Every 
property and conventional test must include a clear rationale and a reference to the originating 
requirement or issue using a full URL so that intent and traceability are preserved across 
refactors.

Assertions are treated as first-class citizens. The assistant adds meaningful assertions that check 
observable behavior for all relevant branches and behaviors rather than relying solely on return 
codes or exception presence. The test suite must maintain strong assertion density, and any 
generated test that does not validate a specific behavioral claim is rejected or rewritten. When 
exact outputs are hard to enumerate, the assistant encodes robust oracles through metamorphic 
relations, requiring at least two independent relations per oracle-hard function so that behavior is 
validated under controlled transformations.

Whenever a reference, specification model, or alternative implementation exists, even if it is 
slower or simpler, the assistant adds differential tests that compare independently implemented 
behavior and turns any discovered discrepancy into a reproducible regression test. For complex 
Boolean logic, the assistant isolates predicate helpers into the smallest feasible units and, where 
warranted by risk, designs tests that achieve modified condition/decision coverage on those helpers 
to expose masking defects without incurring prohibitive cost on wider modules.

Mutation testing is integrated as a guidance signal for test adequacy. The assistant runs mutation 
analysis regularly, studies surviving mutants, and automatically augments tests until a 
project-specific threshold is achieved for the changed code. The threshold is treated as a heuristic 
target rather than a proof of correctness, and the focus remains on killing semantically meaningful 
mutants and documenting the reasoning for any intentionally surviving ones. If dedicated mutation 
tooling is unavailable, the assistant performs targeted, reversible code perturbations to validate 
that tests fail when behavior is subtly altered and then restores the original code.

Fuzz testing is added for any input that involves strings, bytes, files, or protocols by writing Go 
fuzz targets using the built-in fuzzing support in the test framework. The assistant seeds a small 
corpus, preserves discovered inputs, and promotes any fuzzer-found crashes, hangs, or logic faults 
to human-readable regression tests. Fuzzing is run with a bounded time budget locally and in 
continuous integration so that rare paths remain exercised over time without blocking developer 
workflows.

Before code is accepted, the assistant ensures that the changed areas have property-based tests with 
shrinking, meaningful assertions covering all intended behaviors, appropriate metamorphic relations 
where direct oracles are impractical, differential checks when an alternate implementation is 
available, a demonstrated improvement in diversity of exercised inputs and observed outputs relative 
to the prior baseline, a satisfactory mutation score for the touched code with explanations for any 
surviving mutants, and a maintained fuzz harness for relevant inputs. Raw line or branch coverage is 
reviewed to find untested paths but is never used on its own to block or permit a change.

The assistant keeps tests readable, deterministic, and fast by isolating randomness behind 
reproducible seeds, minimizing fixture complexity, and trimming redundant near-duplicate cases that 
do not increase behavioral diversity. All failures discovered by mutation or fuzzing are distilled 
into minimal counterexamples with clear names and explanatory comments so that future contributors 
understand intent and constraints. This rule complements the projectâ€™s broader quality and 
definition-of-done criteria by making strong tests the default path to correctness rather than an 
afterthought.
