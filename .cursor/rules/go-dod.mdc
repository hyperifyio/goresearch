---
description: "Definition of Done enforcing TDD, exhaustive testing, documentation, and CI readiness for every change"
alwaysApply: true
---

This rule defines the projectâ€™s Definition of Done. It applies to all changes 
in source code, tests, documentation, configuration, infrastructure, and data 
migrations. A change is considered complete only when it is demonstrably safe 
to merge and deploy, fully verified by automated checks, documented for 
maintainers and users, and traceable to the issue it implements or fixes.

The team follows test-driven development. For each behavior, a failing test is 
created first or in tight lockstep, the minimal implementation is added to make 
the test pass, and the code is then refactored while keeping the test suite 
green. Every production change must be covered by automated tests. At minimum 
there are unit tests for pure logic and integration tests for boundaries such 
as databases, filesystems, networks, queues, or external services; end-to-end 
tests are required for critical user flows. Regressions reproduceable by a bug 
report must gain a protecting test that fails before the fix and passes after 
it. Coverage must not decrease, and all changed lines and branches must be 
exercised. Tests are deterministic, isolated, and repeatable on any developer 
machine and in CI without network flakiness or timing dependence, using fakes 
or mocks where appropriate.

Traceability is mandatory. Each pull request, commit, and test file explains 
its intent in plain language and links to the canonical GitHub issue using the 
full URL. Tests and implementation contain short comments that state what is 
being verified and why it matters in relation to the issue. If a behavior is 
not expressed as an executable test, it is not considered implemented. Manual 
verification steps, when necessary for UI or operational work, are recorded 
alongside the issue with exact inputs, expected outputs, and results so another 
maintainer can reproduce them.

Quality gates must all pass. The change builds reproducibly, the entire test 
suite is green, static analysis, type checks, formatters, linters, and security 
scanners report no new findings, and secret detection shows no leaks. 
Performance budgets and memory or CPU constraints are respected, and 
long-running or concurrent code is proven safe under load with targeted tests 
or benchmarks when risk exists. Backward compatibility is preserved across 
public interfaces unless the issue explicitly describes a breaking change and 
includes a migration path. Data migrations include idempotent forward scripts, 
tested rollback plans, and verification steps; deployments are safe to roll 
forward or back. Feature flags default to the safest state and include removal 
plans. Documentation is updated in the same change set: user-facing docs for 
visible features, developer docs for architecture or public APIs, operational 
runbooks for configuration or SRE changes, and the changelog when the release 
notes would otherwise be ambiguous. At least one peer review is completed and 
recorded, and all review comments are resolved or explicitly deferred with 
rationale and a linked follow-up issue.

Exceptions are rare and must be approved in the linked issue before merging. 
Any deferred test, refactor, or document must be justified with risk, scope, 
and a concrete follow-up issue URL, and the current change must remain safe to 
ship without it. Hotfixes still include tests in the same pull request whenever 
feasible; if an immediate fix without a test is unavoidable, the protective 
test follows as the next change tied to the same issue without modifying 
production behavior. If any of the requirements above is unmet, the work is not 
done.
