---
description: "Definition of Done enforcing TDD, exhaustive testing, documentation, and CI readiness for every change"
alwaysApply: true
---

This rule defines the projectâ€™s Definition of Done. It applies to all changes in source code, tests, documentation, configuration, infrastructure, and data migrations. A change is considered complete only when it is demonstrably safe to merge and deploy, fully verified by automated checks, documented for maintainers and users, and traceable to the issue it implements or fixes.

The team follows test-driven development. For each behavior, a failing test is created first or in tight lockstep, the minimal implementation is added to make the test pass, and the code is then refactored while keeping the test suite green. Every production change must be covered by automated tests. At minimum there are unit tests for pure logic and integration tests for boundaries such as databases, filesystems, networks, queues, or external services; end-to-end tests are required for critical user flows. Regressions reproduceable by a bug report must gain a protecting test that fails before the fix and passes after it. Coverage must not decrease, and all changed lines and branches must be exercised. Tests are deterministic, isolated, and repeatable on any developer machine and in CI without network flakiness or timing dependence, using fakes or mocks where appropriate.

Traceability is mandatory. Each pull request, commit, and test file explains its intent in plain language and links to the canonical GitHub issue using the full URL. Tests and implementation contain short comments that state what is being verified and why it matters in relation to the issue. If a behavior is not expressed as an executable test, it is not considered implemented. Manual verification steps, when necessary for UI or operational work, are recorded alongside the issue with exact inputs, expected outputs, and results so another maintainer can reproduce them.

Quality gates must all pass. The change builds reproducibly, the entire test suite is green, static analysis, type checks, formatters, linters, and security scanners report no new findings, and secret detection shows no leaks. Performance budgets and memory or CPU constraints are respected, and long-running or concurrent code is proven safe under load with targeted tests or benchmarks when risk exists. Backward compatibility is preserved across public interfaces unless the issue explicitly describes a breaking change and includes a migration path. Data migrations include idempotent forward scripts, tested rollback plans, and verification steps; deployments are safe to roll forward or back. Feature flags default to the safest state and include removal plans. Documentation is updated in the same change set: user-facing docs for visible features, developer docs for architecture or public APIs, operational runbooks for configuration or SRE changes, and the changelog when the release notes would otherwise be ambiguous. At least one peer review is completed and recorded, and all review comments are resolved or explicitly deferred with rationale and a linked follow-up issue.

Exceptions are rare and must be approved in the linked issue before merging. Any deferred test, refactor, or document must be justified with risk, scope, and a concrete follow-up issue URL, and the current change must remain safe to ship without it. Hotfixes still include tests in the same pull request whenever feasible; if an immediate fix without a test is unavoidable, the protective test follows as the next change tied to the same issue without modifying production behavior. If any of the requirements above is unmet, the work is not done.